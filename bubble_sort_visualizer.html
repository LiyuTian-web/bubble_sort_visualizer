<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>冒泡排序可视化（网页版）</title>
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --muted:#94a3b8;
      --accent:#60a5fa;
      --accent-2:#7c3aed;
      --glass: rgba(255,255,255,0.04);
      --success: #86efac;
      --warn: #facc15;
      --white: #f8fafc;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#071026 0%, #071a2a 100%);
      color:var(--white);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:32px;
    }

    .wrapper{
      width:100%;
      max-width:1100px;
      display:grid;
      grid-template-columns:360px 1fr;
      gap:24px;
    }

    .card{
      background:var(--card);
      border-radius:12px;
      padding:18px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      border:1px solid rgba(255,255,255,0.03);
    }

    h1{font-size:18px;margin:0 0 10px 0}
    label{display:block;color:var(--muted);font-size:13px;margin-top:10px}

    .controls{display:flex;flex-direction:column;gap:8px}
    .row{display:flex;align-items:center;gap:8px}
    input[type=number]{width:80px;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--white)}
    .btn{padding:8px 12px;border-radius:8px;border:0;background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#04203a;cursor:pointer;font-weight:600}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--white)}
    .small{font-size:13px;padding:6px 8px}

    .controls .section{margin-top:12px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.02)}

    .visualization-card{position:relative;min-height:360px;display:flex;flex-direction:column}
    .viz-top{display:flex;align-items:center;justify-content:space-between;padding-bottom:12px}
    .viz-stage{flex:1;background:var(--glass);border-radius:10px;padding:12px;position:relative;overflow:hidden}

    /* bar container */
    .bars{position:relative;height:220px;display:block}
    .bar{
      position:absolute;
      top:50%;
      transform:translateY(-50%);
      width:56px;
      height:56px;
      border-radius:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      color:#06203a;
      background:linear-gradient(180deg, #ffffff, #f1f5f9);
      border:1px solid rgba(0,0,0,0.06);
      transition: left 320ms cubic-bezier(.2,.9,.2,1), transform 320ms ease, background-color 180ms ease;
      box-shadow: 0 6px 18px rgba(2,6,23,0.25);
    }

    .bar.green{background:linear-gradient(180deg,#bbf7d0,#86efac)}
    .bar.yellow{background:linear-gradient(180deg,#fff7cc,#facc15)}
    .bar.fixed{opacity:0.85}

    .controls .modes{display:flex;gap:8px;margin-top:8px}
    .muted{color:var(--muted);font-size:13px}

    .footer-hint{margin-top:10px;color:var(--muted);font-size:13px}

    @media (max-width:900px){
      .wrapper{grid-template-columns:1fr;}
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="card">
      <h1>冒泡排序可视化（网页版）</h1>
      <div class="controls">
        <label>数字数量</label>
        <div class="row">
          <input id="num" type="number" min="2" max="20" value="8">
          <button id="start" class="btn">开始排序</button>
          <button id="randomize" class="btn ghost small">随机数组</button>
        </div>

        <div class="section">
          <label>排序方式</label>
          <div class="modes">
            <label><input type="radio" name="order" value="ascending" checked> 升序</label>
            <label><input type="radio" name="order" value="descending"> 降序</label>
          </div>
        </div>

        <div class="section">
          <label>演示模式</label>
          <div class="modes">
            <label><input type="radio" name="demo" value="auto" checked> 自动</label>
            <label><input type="radio" name="demo" value="manual"> 手动</label>
          </div>
        </div>

        <div class="section">
          <label>动画速度（ms）</label>
          <div class="row">
            <input id="speed" type="range" min="80" max="1200" value="500">
            <div class="muted" id="speedVal">500</div>
          </div>
        </div>

        <div class="section">
          <label>手动控制</label>
          <div class="row">
            <button id="prev" class="btn ghost">上一步</button>
            <button id="next" class="btn">下一步</button>
          </div>
          <div class="footer-hint">手动模式下：第一次点击“下一步”高亮（黄色），第二次确认交换并播放动画。</div>
        </div>

      </div>
    </div>

    <div class="card visualization-card">
      <div class="viz-top">
        <div class="muted">可视化面板</div>
        <div class="muted">步骤：<span id="stepIndicator">0 / 0</span></div>
      </div>
      <div class="viz-stage">
        <div id="bars" class="bars"></div>
      </div>
    </div>
  </div>

  <script>
    // --- 状态 ---
    let steps = [];
    let currentStep = 0;
    let timeoutId = null;
    let animating = false;
    let awaitingSwap = false; // 手动模式：已高亮，等待用户确认

    const barsEl = document.getElementById('bars');
    const numInput = document.getElementById('num');
    const startBtn = document.getElementById('start');
    const randomBtn = document.getElementById('randomize');
    const prevBtn = document.getElementById('prev');
    const nextBtn = document.getElementById('next');
    const speedInput = document.getElementById('speed');
    const speedVal = document.getElementById('speedVal');
    const stepIndicator = document.getElementById('stepIndicator');

    function getDemoMode(){
      return document.querySelector('input[name="demo"]:checked').value; // 'auto' or 'manual'
    }
    function getOrder(){
      return document.querySelector('input[name="order"]:checked').value; // 'ascending' or 'descending'
    }

    speedInput.addEventListener('input', ()=>{
      speedVal.textContent = speedInput.value;
    });

    // 生成随机数组
    function randomArray(n){
      const pool = Array.from({length:100}, (_,i)=>i+1);
      // 随机挑选 n 个
      const arr = [];
      for(let i=0;i<n;i++){
        const idx = Math.floor(Math.random()*pool.length);
        arr.push(pool.splice(idx,1)[0]);
      }
      return arr;
    }

    function generateSteps(arr, ascending){
      const s = [];
      const a = arr.slice();
      s.push({array: a.slice(), compared: null, swap:false});
      const n = a.length;
      for(let i=0;i<n-1;i++){
        let swapped = false;
        for(let j=0;j<n-i-1;j++){
          const compared = [j, j+1];
          if((ascending && a[j] > a[j+1]) || (!ascending && a[j] < a[j+1])){
            // 记录交换前状态（高亮并标记需要交换）
            s.push({array: a.slice(), compared: compared.slice(), swap:true, swap_positions:[j,j+1]});
            // 交换实际数据
            const tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp;
            swapped = true;
          }else{
            s.push({array: a.slice(), compared: compared.slice(), swap:false});
          }
        }
        if(!swapped) break;
      }
      s.push({array: a.slice(), compared: null, swap:false});
      return s;
    }

    function clearTimers(){
      if(timeoutId){
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    }

    function renderBars(step){
      // step.array defines current values to display
      barsEl.innerHTML = '';
      const arr = step.array.slice();
      const n = arr.length;
      const containerWidth = barsEl.clientWidth || 700;
      const barWidth = Math.min(64, Math.floor((containerWidth - 20) / Math.max(n,1)) - 8);
      const spacing = 12;
      // recompute positions
      for(let i=0;i<n;i++){
        const val = arr[i];
        const el = document.createElement('div');
        el.className = 'bar';
        el.style.width = barWidth + 'px';
        el.style.left = (i*(barWidth + spacing) + 12) + 'px';
        el.dataset.index = i; // current logical position
        el.dataset.value = val;
        el.textContent = val;
        barsEl.appendChild(el);
      }

      // apply highlight if compared
      if(step.compared){
        const [i,j] = step.compared;
        const els = barsEl.querySelectorAll('.bar');
        if(els[i]){
          if(step.swap){
            els[i].classList.add('yellow');
            els[j].classList.add('yellow');
          }else{
            els[i].classList.add('green');
            els[j].classList.add('green');
          }
        }
      }

      // update step indicator
      stepIndicator.textContent = (currentStep+1) + ' / ' + steps.length;
    }

    function showStep(){
      if(animating) return;
      clearTimers();
      if(currentStep >= steps.length) return;
      const step = steps[currentStep];
      renderBars(step);

      // If this step requires swap animation
      if(step.swap && step.swap_positions){
        const swapPos = step.swap_positions.slice();
        if(getDemoMode() === 'auto'){
          // auto: highlight then delay and animate
          awaitingSwap = false;
          timeoutId = setTimeout(()=>{
            timeoutId = null;
            animateSwap(swapPos);
          }, parseInt(speedInput.value));
        }else{
          // manual: highlight only, wait for user to press next to confirm
          awaitingSwap = true;
        }
      }else{
        // normal compare step: auto advance only if in auto mode
        awaitingSwap = false;
        if(getDemoMode() === 'auto'){
          timeoutId = setTimeout(()=>{
            timeoutId = null;
            currentStep++;
            if(currentStep < steps.length) showStep();
          }, parseInt(speedInput.value));
        }
      }
    }

    function findBarByPos(pos){
      return barsEl.querySelector('.bar[data-index="'+pos+'"]');
    }

    function animateSwap(positions){
      // positions are (i,j) in the arrays of the step BEFORE swap
      if(animating) return;
      animating = true;
      clearTimers();
      const [i,j] = positions;
      const els = barsEl.querySelectorAll('.bar');
      const el1 = els[i];
      const el2 = els[j];
      if(!el1 || !el2){ animating=false; return; }

      // compute current left values and target left
      const left1 = parseFloat(el1.style.left);
      const left2 = parseFloat(el2.style.left);

      // temporarily add transitionend handlers to synchronize end
      let finished = 0;
      function onEnd(e){
        finished++;
        if(finished < 2) return;
        // cleanup listeners
        el1.removeEventListener('transitionend', onEnd);
        el2.removeEventListener('transitionend', onEnd);
        // After animation, to avoid cumulative drift we re-render the next step from steps array
        animating = false;
        currentStep++;
        showStep();
      }

      el1.addEventListener('transitionend', onEnd);
      el2.addEventListener('transitionend', onEnd);

      // set classes to indicate moving
      el1.classList.remove('yellow');
      el2.classList.remove('yellow');

      // swap visuals: move to each other's left
      el1.style.left = left2 + 'px';
      el2.style.left = left1 + 'px';

      // Note: we do not change dataset.index here; after animation completes we rely on showStep() to re-render
      // As fallback, ensure timeout in case transitionend doesn't fire
      clearTimers();
      timeoutId = setTimeout(()=>{
        timeoutId = null;
        if(animating){
          // force finish
          animating = false;
          currentStep++;
          showStep();
        }
      }, parseInt(speedInput.value) + 400);
    }

    // Controls
    startBtn.addEventListener('click', ()=>{
      clearTimers();
      animating = false; awaitingSwap = false;
      const n = parseInt(numInput.value) || 8;
      const arr = randomArray(n);
      steps = generateSteps(arr, getOrder() === 'ascending');
      currentStep = 0;
      showStep();
    });

    randomBtn.addEventListener('click', ()=>{
      const n = parseInt(numInput.value) || 8;
      const arr = randomArray(n);
      // just generate steps but don't start auto-play unless start pressed
      steps = generateSteps(arr, getOrder() === 'ascending');
      currentStep = 0;
      showStep();
    });

    prevBtn.addEventListener('click', ()=>{
      clearTimers();
      if(animating) return;
      awaitingSwap = false;
      if(currentStep > 0) currentStep--;
      showStep();
    });

    nextBtn.addEventListener('click', ()=>{
      clearTimers();
      if(animating) return;
      // if awaitingSwap => perform swap animation
      if(awaitingSwap){
        const step = steps[currentStep];
        if(step.swap && step.swap_positions){
          awaitingSwap = false;
          animateSwap(step.swap_positions);
          return;
        }
      }
      // otherwise just advance one step and render
      if(currentStep < steps.length - 1){
        currentStep++;
        showStep();
      }
    });

    // initial render
    (function init(){
      const initial = randomArray(parseInt(numInput.value)||8);
      steps = generateSteps(initial, getOrder() === 'ascending');
      currentStep = 0;
      showStep();
    })();

    // ensure timers cleared when page hidden/unloaded
    window.addEventListener('beforeunload', ()=>{ clearTimers(); });
  </script>
</body>
</html>
